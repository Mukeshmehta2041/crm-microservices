package com.crm.platform.security.vulnerability;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Pattern;

/**
 * Security vulnerability scanner for common security issues
 */
@Component
public class SecurityScanner {
    
    private static final Logger logger = LoggerFactory.getLogger(SecurityScanner.class);
    
    // Common SQL injection patterns
    private static final Pattern[] SQL_INJECTION_PATTERNS = {
        Pattern.compile("(?i).*('|(\\-\\-)|(;)|(\\|)|(\\*)).*"),
        Pattern.compile("(?i).*(union|select|insert|update|delete|drop|create|alter|exec|execute).*"),
        Pattern.compile("(?i).*(script|javascript|vbscript|onload|onerror).*")
    };
    
    // XSS patterns
    private static final Pattern[] XSS_PATTERNS = {
        Pattern.compile("(?i).*<script.*>.*</script>.*"),
        Pattern.compile("(?i).*javascript:.*"),
        Pattern.compile("(?i).*on(load|error|click|mouseover)=.*"),
        Pattern.compile("(?i).*<iframe.*>.*")
    };
    
    // Path traversal patterns
    private static final Pattern[] PATH_TRAVERSAL_PATTERNS = {
        Pattern.compile(".*\\.\\.[\\\\/].*"),
        Pattern.compile(".*[\\\\/]\\.\\.[\\\\/].*"),
        Pattern.compile(".*%2e%2e[\\\\/].*"),
        Pattern.compile(".*%252e%252e[\\\\/].*")
    };
    
    /**
     * Scan input for potential SQL injection
     */
    public SecurityScanResult scanForSqlInjection(String input) {
        if (input == null || input.trim().isEmpty()) {
            return SecurityScanResult.safe();
        }
        
        List<String> threats = new ArrayList<>();
        
        for (Pattern pattern : SQL_INJECTION_PATTERNS) {
            if (pattern.matcher(input).matches()) {
                threats.add("Potential SQL injection pattern detected");
                logger.warn("SQL injection pattern detected in input: {}", sanitizeForLogging(input));
            }
        }
        
        return threats.isEmpty() ? SecurityScanResult.safe() : 
               SecurityScanResult.threat(ThreatType.SQL_INJECTION, threats);
    }
    
    /**
     * Scan input for potential XSS
     */
    public SecurityScanResult scanForXss(String input) {
        if (input == null || input.trim().isEmpty()) {
            return SecurityScanResult.safe();
        }
        
        List<String> threats = new ArrayList<>();
        
        for (Pattern pattern : XSS_PATTERNS) {
            if (pattern.matcher(input).matches()) {
                threats.add("Potential XSS pattern detected");
                logger.warn("XSS pattern detected in input: {}", sanitizeForLogging(input));
            }
        }
        
        return threats.isEmpty() ? SecurityScanResult.safe() : 
               SecurityScanResult.threat(ThreatType.XSS, threats);
    }
    
    /**
     * Scan input for path traversal attempts
     */
    public SecurityScanResult scanForPathTraversal(String input) {
        if (input == null || input.trim().isEmpty()) {
            return SecurityScanResult.safe();
        }
        
        List<String> threats = new ArrayList<>();
        
        for (Pattern pattern : PATH_TRAVERSAL_PATTERNS) {
            if (pattern.matcher(input).matches()) {
                threats.add("Potential path traversal pattern detected");
                logger.warn("Path traversal pattern detected in input: {}", sanitizeForLogging(input));
            }
        }
        
        return threats.isEmpty() ? SecurityScanResult.safe() : 
               SecurityScanResult.threat(ThreatType.PATH_TRAVERSAL, threats);
    }
    
    /**
     * Comprehensive security scan
     */
    public SecurityScanResult comprehensiveScan(String input) {
        List<SecurityScanResult> results = List.of(
            scanForSqlInjection(input),
            scanForXss(input),
            scanForPathTraversal(input)
        );
        
        List<String> allThreats = new ArrayList<>();
        ThreatType highestThreat = ThreatType.NONE;
        
        for (SecurityScanResult result : results) {
            if (!result.isSafe()) {
                allThreats.addAll(result.getThreats());
                if (result.getThreatType().getSeverity() > highestThreat.getSeverity()) {
                    highestThreat = result.getThreatType();
                }
            }
        }
        
        return allThreats.isEmpty() ? SecurityScanResult.safe() : 
               SecurityScanResult.threat(highestThreat, allThreats);
    }
    
    /**
     * Validate password strength
     */
    public PasswordStrengthResult validatePasswordStrength(String password) {
        if (password == null || password.isEmpty()) {
            return new PasswordStrengthResult(false, 0, List.of("Password cannot be empty"));
        }
        
        List<String> issues = new ArrayList<>();
        int score = 0;
        
        // Length check
        if (password.length() < 8) {
            issues.add("Password must be at least 8 characters long");
        } else if (password.length() >= 12) {
            score += 2;
        } else {
            score += 1;
        }
        
        // Character variety checks
        if (password.matches(".*[a-z].*")) score += 1;
        else issues.add("Password must contain lowercase letters");
        
        if (password.matches(".*[A-Z].*")) score += 1;
        else issues.add("Password must contain uppercase letters");
        
        if (password.matches(".*\\d.*")) score += 1;
        else issues.add("Password must contain numbers");
        
        if (password.matches(".*[!@#$%^&*()_+\\-=\\[\\]{};':\"\\\\|,.<>\\/?].*")) score += 1;
        else issues.add("Password must contain special characters");
        
        // Common password patterns
        if (password.toLowerCase().matches(".*(password|123456|qwerty|admin).*")) {
            issues.add("Password contains common patterns");
            score -= 2;
        }
        
        boolean isStrong = issues.isEmpty() && score >= 5;
        return new PasswordStrengthResult(isStrong, Math.max(0, score), issues);
    }
    
    private String sanitizeForLogging(String input) {
        if (input == null) return "null";
        return input.replaceAll("[\r\n\t]", "_").substring(0, Math.min(input.length(), 100));
    }
}